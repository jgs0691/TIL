KOSTA EDU 재직자 교육

Spring Framework 입문과 활용 1일차

1. Spring DI / IoC
- Spring, Di / IoC 개요
2. MyBatis-Spring
- MyBatis-Spring(Hikari DataSource, Maria DB 연동)

프레임워크란 비기능적(Non-Function) 요구사항(성능, 보안, 확장성, 안정성 등)을 만족하는 구조와 구현된 기능을 안정적으로 실행하도록 제어해주는 잘 만들어진 구조의 라이브러리 덩어리
프레임워크는 애플리케이션들의 최소한의 공통점을 찾아 하부 구조를 제공함으로써 개발자들로 하여금 시스템의 하부 구조를 구현하는데 들어가는 노력을 절감하게 해줌

프레임워크의 정의
- 프레임워크를 사용하는 이유
1. 비기능적인 요소들을 초기 개발 단계마다 구현해야 하는 불합리함을 극복해준다.
2. 기능적인(Functional) 요구사항에 집중할 수 있도록 해준다.
3. 디자인 패턴과 마찬가지로 반복적으로 발견되는 문제를 해결하기 위한 특화된 Solution을 제공한다.

IoC (Inversion of Control)
IoC란 "제어의 역전" 즉, 인스턴스 생성부터 소멸까지의 인서튼서 생명주기 관리를 개발자가 아닌 컨테이너가 대신 해준다는 뜻임.
즉, 컨테이너 역할을 해주는 프레임워크에게 제어하는 권한을 넘겨서 개발자의 코드가 신경 써야 할 것을 줄이는 전략이다.
IoC 컨테이너는 객체의 생성을 책임지고, 의존성을 관리한다.
POJO의 생성, 초기화, 서비스, 소멸에 대한 권한을 가진다.
개발자들이 직접 POJO를 생성할 수 있찌만 컨테이너에게 맡긴다.

프레임워크의 동작원리를 제어흐름이 일반적인 프로그램 흐름과 반대로 동작하므로 IoC 라고 설명함.
Spring 컨테이너는 IoC를 지원하며, 메타데이터(XML설정)를 통해 Beans를 관리하고 어플리케이션의 중요부분을 형성함.
SPring 컨테이너는 관리되는 bean들을 의존성주입(Dependency Injection)을 통해 IoC를 지원함.

프레임워크의 호출흐름은 프레임워크 코드가 유저코드를 호출한다.
라이브러리의 호출흐름은 유저코드가 라이브러리를 호출한다.
프레임워크와 라이브러리를 구분하는 방법은 실행제어가 어디서 일어나는 가에 달려있다고 볼 수 있다.

Spring Framework 란 Java 엔터프라이즈 개발을 편하게 해주는 오픈소스 경량급 애플리케이션 프레임워크이다.
개발자가 복잡하고 실수하기 쉬운 Low Level에 많이 신경쓰지 않으면서 Business Logic 개발에 전념할 수 있도록 해준다.
Spring은 오픈소스의 장점을 충분히 취하면서 동시에 오픈소스 제품의 단점과 한계를 잘 극보함.

Spring 의 특징
1. Portable Service Abstraction
추상화를 통해 Low Level의 기술구현 부분과 기술을 사용하는 인터페이스로 분리한다.
2. 객체지향과 DI
Spring은 객체지향에 충실한 설계가 가능하도록 단순한 객체 형태로 개발 할 수 있고, DI는 유연하게 확장 가능한 객체를 만들어 두고 그 관계는 외부에서 설정해준다.
3. AOP(Aspect Oriented Programming)
AOP는 애플리케이션 로직을 담당하는 코드에 남아 있는 기술 관련 코드를 분리해서 별도의 모듈로 관리하게 해주는 강력한 기술이다.
4. POJO(Plain Old Java Object)
POJO는 객체지향 원리에 충실하면서, 특정 환경이나 규약에 종속되지 않고 필요에 따라 재활용 될 수 있는 방식으로 설계된 객체이다.

DI의 개념
각 클래스간의 의존관계를 빈 설정 (Bean Definition) 정보를 바탕으로 컨테이너가 자동으로 연결해주는 것을 말함
개발자들은 단지 빈 설정파일에서 의존관계가 필요하다는 정보를 추가하면 된다.
객체 레퍼런스를 컨테이너로부터 주입 받아서, 실행 시에 동적으로 의존관계가 생성된다.
컨테이너가 흐름의 주체가 되어 애플리케이션 코드에 의존관계를 주입해 주는 것이다.

DI의 장점
코드가 단순해진다.
컴포넌트 간의 결합도가 제거된다.

DI 용어
1. 빈(Bean)
스프링이 IoC 방식으로 관리하는 객체라는 뜻
스프링이 직접 생성과 제어를 담당하는 객체를 Bean 이라고 부름
2. 빈 팩토리(BeanFactory)
스프링의 IoC를 담당하는 핵심 컨테이너를 가리킴
Bean을 등록, 생성, 조회, 반환하는 기능을 당담함
이 BeanFactory를 바로 사용하지 않고 이를 확장한 ApplicationContext를 주로 이용함
3. 애플리케이션 컨텍스트 (ApplicationContext)
BeanFactory를 확장한 IoC 컨테이너
Bean을 등록하고 관리하는 기능은 BeanFactory와 동일하지만 스프링이 제공하는 각종 부가 서비스를 추가로 제공함
스프링에서는 ApplicationContext를 BeanFactory보다 더 많이 사용함
4. 설정 메타정보(Configuration metadata)
ApplicationContext 또는 BeanFactory가 IoC를 적용하기 위해 사용하는 메타정보를 말함
설정 메타정보는 IoC컨테이너에 의해 관리되는 Bean 객체를 생성하고 구성할 때 사용됨

DI의 유형
1. Setter Injection
의존성을 입력 받는 setter 메서드를 만들고 이를 통해 의존성을 주입한다.
2. Constructor Injection
필요한 의존성을 포함하는 클래스의 생성자를 만들고 이를 통해 의존성을 주입한다.
3. Method Injection
의존성을 입력 받는 일반 메서드를 만들고 이를 통해 의존성을 주입한다.

Bean 의존관계
Setter Injection : <property> 태그
Setter 메서드를 통해 의존관계가 있는 Bean을 주입하려면 <property> 태그의 ref 속성을 사용 할 수 있다. ref 속성은 사용하면 Bean의 id를 이용해 주입할 Bean을 찾는다.
Setter 메서드를 통해 Bean의 레퍼런스가 아니라 단순 값을 주입하려고 할 때는 <property> 태그의 value 속성을 사용한다. value 속성은 단순 값 또는 Bean이 아닌 객체를 주입할 때 사용한다.
Constructor를 통해 의존관계가 있는 Bean을 주입하려면 <constructor-arg>태그를 사용할 수 있다.
Constructor 주입방식은 생성자의 파라미터를 이용하기 때문에 한번에 여러 개의 객체를 주입 할 수 있다.
	생성자 주입을 위한 설정 : index 지정
	<bean id=“hello” class=“myspring.di.xml.Hello”>
		<constructor-arg index=“0” value=“Spring”/>
		<constructor-arg index=“1” ref=“printer”/>
	</bean>
	생성자 주입을 위한 설정 : 파라미터 이름 지정
	<bean id=“hello” class=“myspring.di.xml.Hello”>
		<constructor-arg name=“name” value=“Spring”/>
		<constructor-arg name=“printer” ref=“printer”/>
	</bean>
컬렉션(Collection) 타입의 값 주입(Injection)
<list>와 <value> 태그를 이용
프로퍼티가 Set 타입 이면 <list> 대신에 <set>을 사용하면 된다.

Spring은 List, Set, Map, Properties와 같은 컬렉션 타입을
XML로 작성해서 프로퍼티에 주입하는 방법을 제공한다.
<map>과 <entry> 태그를 이용

JUnit을 사용한 DI 테스트 클래스
JUnit은 Java에서 독립된 단위테스트(Unit Test)를 지원해주는 프레임워크이다.

단위테스트(Unit Test)란 소스 코드의 특정 모듈이 의도된 대로 정확히 작동하는지 검증하는 절차, 즉 모든 함수와 메소드에 대한 테스트 케이스(Test case)를 작성하는 절차를 말한다.
jUnit은 보이지 않고 숨겨진 단위 테스트를 끌어내어 정형화시켜 단위테스트를 쉽게 해주는 테스트 지원 프레임워크다.

jUnit에서 테스트를 지원하는 어노테이션(Annotation)
@Test
선언된 메서드는 테스트를 수행하는 메소드가 된다.
Junit은 각각의 테스트가 서로 영향을 주지 않고 독립적으로 실행됨을 원칙으로 @Test 마다 객체를 생성한다.
@Disabled
@Disabled가 선언된 메서드는 테스트를 실행하지 않게 한다.
@BeforeEach가 선언된 메서드는 @Test 메소드가 실행되기 전에 반드시 실행되어 진다.
@Test 메소드에서 공통으로 사용하는 코드를 @BeforeEach 메소드에 선언하여 사용하면 된다.

테스트 결과를 확인하는 단정(assert) 메서드
assertEquals(a, b); : 객체 A와 B의 갑이 일치함을 확인한다.
assertSame(a, b); : 객체 A와 B의 주소 값이 일치함을 확인한다.

Spring-Test에서 테스트를 지원하는 어노테이션(Annotation)
@ExtendWith(SpringExtension.class)
@ExtendWith는 jUnit 프레임워크의 테스트 실행방법을 확장할 때 사용하는 어노테이션이다.
@ExtendWith 어노테이션은 각각의 테스트 별로 객체가 생성되더라도 싱글톤(Singleton)의 ApplicationContext를 보장한다.

@ContextConfiguration
스프링 빈(Bean) 설정 파일의 위치를 지정할 때 사용되는 어노테이션이다.

@Autowired
해당 변수에 자동으로 빈(Bean)을 매핑 해준다.
스프링 빈(Bean) 설정 파일을 읽기 위해 GenericXmlApplicationContext를 사용 할 필요가 없다.
정밀한 의존관계 주입 (Dependency Injection)이 필요한 경우에 유용하다.
변수, setter 메서드, 생성자, 일반메서드에 적용 가능하다.
의존하는 객체를 주입할 때 주로 Type을 이용하게 된다.
@Autowired는 <property>, <constructor-arg> 태그와 동일한 역할을 한다.

@Resource
어플리케이션에서 필요로 하는 자원을 자동 연결할 때 사용된다.
@Resource는 변수, setter 메서드에 적용 가능하다.
의존하는 객체를 주입할 때 주로 Name을 이용하게 된다.

@Value
단순한 값을 주입할 때 사용되는 어노테이션이다. 
@Value(“Spring”)은 <property .. value=“Spring” /> 와 동일한 역할을 한다.

@Qualifier
@Qualifier는 @Autowired 어노테이션과 같이 사용되어 진다. 
@Autowired는 타입으로 찾아서 주입하므로, 동일한 타입의 Bean객체가 여러 개 존재할 때 특정 Bean을 찾기 위해서는 @Qualifier를 같이 사용해야 한다.

Bean 등록 메타정보 구성 전략
전략(1) XML 설정 단독 사용
모든 Bean을 명시적으로 XML에 등록하는 방법이다.
생성되는 모든 Bean을 XML에서 확인할 수 있다는 장점이 있으나 Bean의 개수가 많아지면 XML 파일을 관리하기 번거로울 수 있다.
여러 개발자가 같은 설정파일을 공유해서 개발하다 보면 설정파일을 동시에 수정하다가 충돌이 일어나는 경우도 적지 않다.
DI에 필요한 적절한 setter 메서드 또는 constructor가 코드 내에 반드시 존재해야 한다.
개발 중에는 어노테이션 설정방법을 사용했지만, 운영 중에는 관리의 편의성을 위해 XML설정으로 변경하는 전략을 쓸 수도 있다.

전략(2) 어노테이션과 XML 설정 혼용해서 사용 (ver2.5) (주로 사용)
Bean으로 사용될 클래스에 특별한 어노테이션(Annotation)을 부여해주면 이런 클래스를 자동으로 찾아서 Bean으로 등록한다.
@Component 어노테이션이 선언된 클래스를 자동으로 찾아서 Bean으로 등록 해주는 방식을 빈 스캐닝(Bean Scanning)을 통한 자동인식 Bean 등록 기능이라고 한다.
어노테이션을 부여하고 자동 스캔으로 Bean을 등록하면 XML 문서 생성과 관리에 따른 수고를 덜어주고 개발 속도를 향상시킬 수 있다.
애플리케이션에 등록될 Bean이 어떤 것들이 있고, Bean들 간의 의존관계가 어떻게 되는지를 한눈에 파악할 수 없다는 단점이 있다.
<context:component-scan> 태그를 사용하며,
@Component를 통해 자동으로 Bean을 등록하고, @Autowired로 의존관계를 주입받는 어노테이션을 클래스에서 선언하여 사용했을 경우에는 해당 클래스가 위치한 특정 패키지를 Scan하기 위한 설정을 XML에 해주어야 한다.
<context:include-filter>태그와 <context:exclude-filter>태그를 같이 사용하면 자동 스캔 대상에 포함시킬 클래스와 포함시키지 않을 클래스를 구체적으로 명시할 수 있다.

전략(3) 어노테이션 설정 단독 사용 (ver3.0)
Spring JavaConfig 프로젝트는 XML이 아닌 자바 코드를 이용해서 컨테이너를 설정할 수 있는 기능을 제공하는 프로젝트이다.
@Configuration 어노테이션과 @Bean 어노테이션을 이용해서 스프링 컨테이너에 새로운 빈 객체를 제공할 수 있다.
Spring 3.0 부터는 어노테이션을 이용한 Bean의 등록 및 Bean들 간의 연결 설정을 자바 코드 내부에 하므로 XML을 전혀 사용하지 않는다.

Bean 등록 Annotation
@Repository
퍼시스턴스(persistence) 레이어, 영속성을 가지는 속성(파일, 데이터베이스)을 가진 클래스

@Service
서비스 레이어, 비즈니스 로직을 가진 클래스

@Controller
프리젠테이션 레이어, 웹 어플리케이션에서 웹 요청과 응답을 처리하는 클래스

@Component
컴포넌트를 나타내는 일반적인 스테레오 타입으로 <bean> 태그와 동일한 역할을 함 (위의 3개를 퉁친거라고 볼 수 있다)

프로퍼티(Property) 파일을 이용한 설정 방법
환경에 따라 자주 변경되는 내용의 분리
XML의 Bean 설정 메타정보는 애플리케이션 구조가 바뀌지 않으면 자주 변경되지 않는다.
반면에 프로퍼티 값으로 제공되는 일부 설정정보 (예-DataSource Bean이 사용하는 DB 연결정보)는 애플리케이션이 동작하는 환경(개발, 테스트, 스테이징, 운영)에 따라서 자주 바뀔 수 있다.
변경되는 이유와 시점이 다르다면 분리하는 것이 객체지향 설계의 기본 원칙이다. 설정에도 동일한 원칙을 적용할 수 있다.
환경에 따라 자주 변경될 수 있는 내용은 properties 파일로 분리하는 것이 가장 깔끔하다 XML 처럼 복잡한 구성이 필요 없고 키와 값의 쌍(key=value)으로 구성하면 된다.
프로퍼티 파일로 분리한 정보는 ${ } (프로퍼티 치환자)을 이용하여 설정한다.
${ } 값을 치환해주는 기능은 <context:property-placeholder> 태그에 의해 자동으로 등록되는 PropertyPlaceHolderConfigurer Bean이 담당한다.

